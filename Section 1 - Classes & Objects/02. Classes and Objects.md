# Reading Material: 
- Starting out with C++: Chapter 13
---
# Writing your Classes
## 1. Separating Specification and Implementation
- **Header Files (`MyClass.h`)**:
    - **Purpose**: The header file contains the class specification or declaration. This includes the class name, attributes, method prototypes, and any other declarations necessary for the class.
- **Implementation Files (`MyClass.cpp`)**:
	- **Purpose**: The implementation file contains the actual implementation of the methods declared in the header file. This is where the logic of the methods is defined.
- **Including the Header in the Implementation File**:
    - **Purpose**: To ensure that the implementation file knows about the class structure, the header file must be included at the top of the implementation file using the `#include` directive.
    - **Rule**: Always include the header file corresponding to the class in the implementation file.
- **Compilation Rules**:
    - **Implementation Files**: `.cpp` files are compiled by the compiler to create object files or directly into executable code.
    - **Header Files**: Header files (`.h`) cannot be compiled directly. They are included by other files (typically `.cpp` files) and serve to define the structure and interfaces of the classes.
- **Important Warning**:
    - **NEVER `#include` a `.cpp` File**: Including `.cpp` files is a bad practice that can lead to multiple definitions of functions and other issues during the linking process. Always include the `.h` file instead.
## 2. Inline Methods
- **Definition**: Inline methods are methods that are implemented directly within the class specification (typically in the header file). When the compiler encounters an inline method, it may substitute the method's code directly at the point of the call rather than making a traditional function call.
- **Substitution During Compilation**:
    - **How it Works**: During compilation, the compiler replaces the call to an inline method with the actual code of the method itself. This can improve execution speed by eliminating the overhead of a function call.
- **Speed vs. Executable Size**:
    - **Trade-offs**: Inlining methods can increase the speed of execution, especially for small methods. However, it can also increase the size of the executable because the method code is duplicated wherever it is called.
    - **Guideline**: A common guideline is to "inline all 1-liners," meaning that simple, short methods (like getters and setters) are good candidates for inlining.
- **`inline` Keyword**:
    - **Purpose**: The `inline` keyword can be used to suggest that the compiler should inline a function, even if the function is defined separately from the class specification.
---
# Access Specifiers
## 1. Introduction to Access Specifiers
- **Definition**: Access specifiers in Object-Oriented Programming (OOP) determine the visibility and accessibility of a class's members (attributes and methods). They control whether the data and methods within a class can be accessed from outside the class or only within it.
- **Purpose**: The primary purpose of access specifiers is to enforce encapsulation, ensuring that the internal workings of a class are protected and only exposed as necessary.
## 2. Types of Access Specifiers
- **`public`**:
    - **Definition**: Members declared as `public` are accessible both inside and outside the class definition. This means they can be accessed and modified by any part of the program that has access to the object.
    - **Use Case**: Typically used for methods or attributes that need to be accessible from outside the class, such as interface functions that interact with the object's data.
    - **Example**: In a `Square` class, a method like `getSide()` might be declared as `public` to allow external code to retrieve the value of the `side` attribute.
- **`private`**:
    - **Definition**: Members declared as `private` are only accessible within the class definition. They cannot be accessed directly from outside the class.
    - **Use Case**: Commonly used to protect the internal state of an object, ensuring that its data cannot be altered directly from outside the class. Instead, access is controlled through public methods.
    - **Example**: In a `Square` class, the `side` attribute might be declared as `private`, preventing external code from modifying it directly. Instead, a public method like `setSide()` would be provided to modify it safely.
- **`protected`**:
    - **Definition**: Members declared as `protected` are similar to `private` but with one key difference: they can be accessed within the class itself and by derived classes (subclasses) in an inheritance hierarchy.
    - **Use Case**: Primarily used in inheritance to allow subclasses to access and modify the protected members of their parent class while still preventing external access.
    - **Current Context**: For now, you can think of `protected` as `private`, with its specific role in inheritance to be covered in more detail later.
## 3. Default Access Levels
- **For Classes**: In C++, if no access specifier is explicitly mentioned, the default access level for members of a class is `private`.
- **For Structs**: Conversely, in a `struct`, the default access level for members is `public`. This distinction reflects the typical use of structs for simpler data structures where public access is more common.
## 4. Access Specifier Example
``` c++
class Square { 
	public: 
		int getSide() const { return side; } 
		void setSide(int newSide) { side = newSide; } 
	private: 
		int side = 1; 
}; 

int main() { 
	Square mySquare; 
	mySquare.side = 2; // !!Compiler error!! - Unable to modify private attribute. 
	mySquare.setSide(2); // We are able to modify the side attribute with this public method. 
	std::cout << "mySquare side is " << mySquare.side << "\n"; // !!Compiler error!! - Unable to access private attribute. 
	std::cout << "mySquare side is " << mySquare.getSide() << "\n"; // We can access the attribute with this method. 
}
```
- **`private` Attribute**: The `side` attribute is declared as `private`, which means it cannot be accessed or modified directly from outside the `Square` class.
- **Attempt to Modify `side` Directly**: In the `main` function, trying to set `mySquare.side = 2;` results in a compiler error because `side` is private.
- **Modifying `side` via `setSide()`**: The `setSide(int newSide)` method is declared as `public`, so it can be used to modify the `side` attribute safely.
- **Accessing `side` Directly**: Attempting to access `mySquare.side` directly in the `main` function also results in a compiler error due to its private access level.
- **Accessing `side` via `getSide()`**: The `getSide()` method, declared as `public`, allows external code to retrieve the value of `side` safely.
## 5. Lining Up Access Specifiers
- **Multiple Access Levels in a Class**: In a single class, you can use different access specifiers to control access to different members. It's common to group related members together under the same access level for clarity.
- **Order Flexibility**: The order in which you declare access specifiers within a class does not matter. You can organize your class members in any order that makes sense for your design.
- **Multiple Declarations**: You can declare the same access specifier multiple times within a class if you want to separate different sections of your code or if you prefer a specific organizational style.
	```c++
class Example { 
	public: // First public section 
		void publicMethod1(); 
	private: // First private section 
		int privateAttribute1; 
	protected: // First protected section 
		void protectedMethod1(); 
	public: // Second public section 
		void publicMethod2(); 
	private: // Second private section 
	int privateAttribute2; 
};
```
## 6. Conclusion
- **Summary**: Access specifiers (`public`, `private`, `protected`) play a crucial role in controlling how data and methods are accessed within an object-oriented program. They enforce encapsulation by limiting direct access to an object's internal state, ensuring that only approved methods can interact with the data.
- **Next Steps**: Understanding access specifiers is essential as we delve deeper into concepts like inheritance, where `protected` plays a more significant role in allowing controlled access between parent and child classes.
---
# Methods
## 1. Introduction to Methods
- **Definition**: Methods are functions that belong to a class. They define the behaviors or actions that objects of that class can perform. In C++, methods are typically declared within a class and can be defined in a separate file.
## 2. Prototype in Class Declaration
- **Method Prototypes**: In C++, method prototypes are declared within the class definition. This allows the compiler to know what methods are available for objects of that class.
- **Purpose**: Prototyping in the class declaration enables the compiler to ensure that any calls to these methods are valid, even if their full implementation is defined elsewhere.
## 3. Definition in a Separate Implementation File
- **Implementation Files**: While method prototypes are in the class declaration (usually in a header file), the actual implementation of these methods is often placed in a separate implementation file (commonly with a `.cpp` extension).
- **Flexibility**: Although the implementation is often in a separate file, it can also be included in the same file as the class declaration if desired, especially for small or inline methods.
```c++ title:Square.h
class Square { 
	public: 
		int getSide() const; 
		void setSide(int newSide); 
	private: 
	int side; 
};
```
## 4. Scope Resolution Operator (`::`)
- **Purpose**: The scope resolution operator (`::`) is used to define the relationship between a method and the class it belongs to, particularly when the method implementation is separated from its declaration.
- **Usage**: When implementing methods outside the class definition, the `::` operator is used to indicate which class the method belongs to.
```c++ title:Square.cpp
int Square::getSide() const { return side; }
void Square::setSide(int newSide) { side = newSide; }
```
- Here, `Square::getSide` tells the compiler that `getSide()` is a method belonging to the `Square` class.
## 5. Private Methods
- **Definition**: Private methods are methods that can only be accessed from within the class in which they are defined. They are not accessible from outside the class.
- **Usefulness**: Private methods are useful for breaking down complex operations within a class. They allow the class to manage its internal workings without exposing unnecessary details to the outside world.
- **Example**: A private method might handle a complex calculation or a helper function that is not intended to be part of the class's public interface.
## 6. Accessors and Mutators
- **Accessors**:
    - **Definition**: Accessors are methods that allow you to retrieve the values of a class's attributes. They should not modify the attribute values and are typically marked as `const` to prevent accidental modification.
    - **Example**: `{c++}int Square::getSide() const { return side; }`
- **Mutators**:
	- **Definition**: Mutators are methods that allow you to modify the values of a class's attributes.
	- **Example**: `{c++}void Square::setSide(int newSide) { side = newSide; }`
- **Getters and Setters**: Accessors and mutators are often referred to as "getters" and "setters" because they typically follow a naming convention like `getAttribute()` and `setAttribute()`.
- **Principle of Least Privilege**: By using accessors and mutators, you can control how data is accessed and modified, adhering to the principle of least privilege, which states that code should only have access to the data and methods it needs to perform its tasks.
- **Avoidance of Stale Data and Incorrect States**: Accessors and mutators help ensure that data remains consistent and valid, preventing the class from entering an invalid or inconsistent state.
```c++
void Square::setSide(int newSide) { 
	if(newSide > 0)
		side = newSide; 
}
```
## 7. `const` Methods
- **Definition**: In C++, a method can be marked as `const` to indicate that it promises not to modify the state of the object. This means that the method will not alter the values of the object's attributes.
- **Usage**: `const` methods are commonly used for accessors, ensuring that methods intended to only retrieve data do not inadvertently change the object's state.
- **Mutators and `const`**: Since mutators are designed to modify the object's state, they cannot be declared as `const` methods.
## 7. Conclusion
- **Summary**: Methods are central to defining the behavior of objects in OOP. By separating method prototypes and implementations, using the scope resolution operator, and implementing accessors and mutators, developers can create well-structured, maintainable, and secure code.
- **Best Practices**: Organize method declarations in header files and definitions in implementation files for clarity. Use accessors and mutators to safely interact with class attributes, and leverage private methods to encapsulate internal logic. When designing your classes, make it a habit to declare methods as `const` whenever they do not modify the state of the object. This not only provides a guarantee that the method is safe to use without side effects but also makes your code more self-documenting and easier to understand. Consistently applying the `const` keyword to appropriate methods enhances code reliability and helps prevent accidental modifications to the object's state.
---
# Constructors and Destructors
## 1. Constructors
- **Purpose**: Constructors are special methods in a class that are called when an object is instantiated. Their primary role is to initialize the object to a working state immediately upon creation, avoiding uninitialized states that regular data or `struct`s might begin with.
- **Key Characteristics**:
    - **No Return Type**: Constructors do not have a return type, not even `void`.
    - **Naming**: Constructors must have the same name as the class they belong to.
- **Default Constructor**:
    - **Definition**: A default constructor is a constructor that takes no parameters. It is used to create a "default" or "blank" object with initial values.
- **Parameterized Constructors**:
	- **Purpose**: Constructors can take parameters to allow for the initialization of attributes with specific values during object instantiation.

- ## **2. Uniform Initialization Syntax**
- **Introduction**: Added in C++11, uniform initialization syntax allows for a consistent way to initialize all types of variables, including objects, primitives, and arrays, using a single curly brace `{}` syntax.
- **Benefits**:
    - **Consistency**: This syntax provides a uniform way to initialize different types of variables, making the code more consistent and easier to read.
    - **Initialization**: Uniform initialization can prevent certain types of bugs related to uninitialized variables, as it requires all values to be explicitly provided.
- **Old Syntax Still Works**:
	- **Compatibility**: While uniform initialization is recommended for new code, the older syntax (using parentheses or the assignment operator) still works and can be used when necessary.
```c++
int age{23};
Rectangle classroom{24, 30};
// The following is an array - we will talk more about these soon:
double temperatures[]{78.8, 80.2, 92.4, 87.5, 95.3, 95.1, 92.8};
```
-  **Constructor Initialization Lists**:
	- **Compact Syntax**: Constructor initialization lists offer a compact and efficient syntax for initializing class attributes directly.
	- **Early Initialization**: Initialization lists guarantee that attributes are initialized before the body of the constructor executes.
	- **No Name Disambiguation Required**: In constructor initialization lists, the syntax of the language removes the need for name disambiguation between parameters and member variables.
```c++
class Square {
    public:
         // Default constructor
        Square() { side = 1; }

		// Parameterized constructor with Initialization List
        Square(int side) : side{side} {} 
    private:
        int side;
};
```
## 3. Destructors
- **Purpose**: Destructors are special methods in a class that are called automatically when an object is destroyed, either by being deleted or when it goes out of scope.
- **Naming and Characteristics**:
    - **Naming**: Destructors have the same name as the class, but with a `~` (tilde) prefix.
    - **No Return Type**: Like constructors, destructors do not have a return type.
    - **No Parameters**: Destructors cannot take any parameters.
    - **Non-Overloadable**: Destructors cannot be overloaded—there can be only one destructor per class.
- **When and Why Destructors are Needed**:
    - **Resource Management**: Destructors are crucial for managing resources, such as memory, file handles, or network connections. They ensure that these resources are properly released when an object is no longer needed, preventing resource leaks.
## 4. Timings: When Constructors and Destructors Are Called
- **Constructor Timing**:
    - **When Called**: Constructors are called automatically when an object is created. This happens when an object is declared, allocated dynamically with `new`, or copied from another object (if a copy constructor is used).
    - **Order of Execution**: In classes with inheritance, the base class constructor is called before the derived class constructor.
- **Destructor Timing**:
    - **When Called**: Destructors are called automatically when an object goes out of scope, is explicitly deleted, or when a program ends and the object is still in memory.
    - **Order of Execution**: In classes with inheritance, the derived class destructor is called before the base class destructor, ensuring that resources in derived classes are cleaned up before the base class resources.
## 5. Overloading in Classes
- **Constructor Overloading**:
    - **Definition**: Constructor overloading allows a class to have multiple constructors with different parameters, enabling objects to be instantiated in various ways.
    - **Consequences**: If you overload constructors and do not explicitly provide a default constructor, the class will not have a default constructor automatically.
- **Method Overloading**:
	- **Definition**: Methods in a class can also be overloaded by defining multiple methods with the same name but different parameter types or numbers of parameters.
- **Destructor Overloading**:
	- **Important Note**: Destructors cannot be overloaded. A class can have only one destructor, which is automatically called when the object is destroyed.
## 6. Conclusion
- **Summary**: Constructors and destructors are essential components of object lifecycle management in OOP. The addition of uniform initialization syntax in C++11 further enhances the ability to initialize variables consistently and safely. Understanding the timings of when constructors and destructors are called, along with the rules around overloading, is crucial for writing efficient, reliable, and maintainable code.
---
# Pointers to Objects and the `this` Keyword
## 1. Introduction to Pointers
- **Definition**: A pointer is a variable that stores the memory address of another variable. Instead of holding a direct value, a pointer "points" to the location in memory where the value is stored.
- **Use in Object-Oriented Programming**: Pointers can also point to objects, allowing you to work with objects indirectly through their memory address.
## 2. Pointers to Objects
- **Arrow Notation (`->`)**:
    - **Purpose**: When you have a pointer to an object, the arrow notation (`->`) is used to access the object's members, such as methods or attributes.
## 3. The `this` Keyword
- **Definition**: `this` is a keyword in C++ that represents a pointer to the current object within a class method.
- **Use in Methods**:
    - **Disambiguation**: When a method has a parameter or local variable with the same name as an object's attribute, `this` is used to distinguish the attribute from the parameter.
```c++
class Rectangle {
	Rectangle(int l, int w) : length{l}, width{w} {}
	void setLength(int length) { this->length = length; }
	private:
	    int length;
	    int width;
};

int main() {
	// Create a rectangle and name it myRectangle.
	Rectangle myRectangle(2,4);
	// Create a Rectangle pointer and point it at
	// myRectangle.
	Rectangle* myPtr = &myRectangle;

	// When this function is called, myRectangle
	// will be basically what replaces "this"
	// in above. You could look at this like:
	// myRectangle.length = 4
	myPtr->setLength(4);
}
```
**Explanation**: In the `set_length` method, `this->length` refers to the object's `length` attribute, while `length` refers to the method's parameter.
## 4. Conclusion
- **Summary**: Pointers allow you to reference objects indirectly, and the arrow notation (`->`) is used to access members of an object through a pointer. The `this` keyword is a built-in pointer that allows an object to refer to itself within its methods, helping to resolve naming conflicts and making the code more clear and maintainable.