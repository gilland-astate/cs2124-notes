---
aliases: 
theme: black
highlightTheme: monokai
margin: "0"
width: "960"
height: "540"
transition: slide
defaultTemplate: "[[Courses I Teach/Object Oriented Programming/OOP Lecture Notes/Y. Slides/assets/slide-templates/tpl-astate-base]]"
maxScale: "20.0"
center: "false"
css: ./css/local.css
---

<!-- slide template="[[tpl-astate-title]]" -->
::: title
# Objects
:::
- Chapter 13

---
::: title
Separating Specification and Implementation
:::
- Header files ( _`MyClass`_`.h` ) – place class specification (declaration) here
- Implementation file ( _`MyClass`_`.cpp` ) – implement methods here
- `#include` the header from the implementation file
- Implementation ( `.cpp` ) files can be compiled; header files cannot.
- **NEVER** `#include` a `.cpp` file!
---
::: title
Inline Methods
:::
- Implemented directly in class specification.
- Substituted during compilation.
- Speed VS executable size
- “inline all 1-liners”
- `inline` keyword
    - Can be used to inline functions implemented separately.
---
::: title
Constructors
:::
- Allow an object to be _instantiated_ (created) in an already-working state.
    - Contrast this with the _uninitialized_ state that regular data and `struct`s begin with.
- Constructors _do not_ have any return type.
- Constructors have the same name as the class.
- _Default constructor_ is a constructor that takes no parameters; used to create a "default" or "blank" object.
- Constructors may take parameters to allow _initialization_ during instantiation.
- Classes do not always have a default constructor.
---
::: title
c-tor initialization lists
:::
- Compact syntax for placing values into attributes in a constructor implementation.
- Guarantees initialization _before_ body of constructor executes.
```c++
struct Rectangle{
	Rectangle(int l, int w) : length{l}, width{w} {}
	int length;
	int width;
};
```
The body of the constructor above is _empty_ since there is no more initialization work to do... But the body (curly braces) is still required syntactically.

---
::: title
c-tor initialization lists
:::
There is no need for name disambiguation in a constructor initialization list, due to the syntactic requirements of the language.
``` c++
struct Rectangle{
	Rectangle(int length, int width) : length{length}, width{width} {}
	int length;
	int width;
};
```
This can allow you to write more expressive code, more easily.

---
::: title
Destructors
:::
- Called when object is destroyed
    - Either by being deleted or going out of scope
- Named same as class, but begins with `~`
- No return value, no parameters
- Cannot be overloaded
- ... when and why destructors are needed
---
::: title
Overloading
:::
- Constructors may be overloaded
    - Remember that there are consequences for default constructor
- Methods may be overloaded
- Destructors _may NOT_ be overloaded
---
::: title
Sneek Peek: Pointers to Objects
:::
- Uses same pointer notation
- “dot-notation” becomes “arrow-notation”:
- Arrow operator ( `->` )
- Dynamic allocation of objects is possible (coming soon...)
---
::: title
**`this` keyword**
:::
- `this` is a keyword representing a _pointer to_ the current object.
- Used to disambiguate naming within method bodies.
``` c++
struct Rectangle{
	Rectangle(int l, int w);
	void set_length(int length){
		this->length = length;
	}    // [...] other methods not shown.
	private:    
		int length;
		int width;
};
```
---
::: title
Uniform Initialization Syntax
:::
- Added in C++11
- Allows initialization of all types of variables with the same syntax.
- The "old" syntax for each type still works, but consider using uniform syntax.
``` c++
int age{23};
Rectangle classroom{24, 30};
// The following is an array - we will talk more about these soon:
double    temperatures[]{78.8, 80.2, 92.4, 87.5, 95.3, 95.1, 92.8};
```
---
::: title
Other Details
:::
- Timing of constructors, destructors
- Arrays of objects
    - Requires default constructor ...
    - ... unless initialization syntax is used.
        - May provide arguments only or constructor invocations.
---
::: title
`const` methods
:::
- In classes / structures, a method can "promise" not to modify the _state_ of the object.
    - meaning, values of attributes will not be modified
- accomplished by marking methods as `const`
- This protection is often added to accessors, and _should_ be added whenever possible.
- Mutators cannot be `const` methods, since they need to change the state of the object.
---
::: title
const example
:::
``` c++
class Rectangle{
	public:    
		int get_length() const;  // const method    
		//[... other code not shown ...]
	private:
		int length;    
		int width;
};
```

`get_length()` _cannot_ modify the attributes (`length` and `width`).