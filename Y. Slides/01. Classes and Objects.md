---
aliases: 
theme: black
highlightTheme: monokai
margin: "0"
width: "960"
height: "540"
transition: slide
defaultTemplate: "[[Courses I Teach/Object Oriented Programming/OOP Lecture Notes/Y. Slides/assets/slide-templates/tpl-astate-base]]"
maxScale: "20.0"
center: "false"
css: ./css/local.css
---
<!-- slide template="[[tpl-astate-title]]" -->
::: title
# Classes and Objects
:::
- Chapter 13

---
::: title 
Procedural (Structured) Programming
:::
* **Function-Centric**: Focuses on dividing the program into small, manageable procedures or *functions*.
* **Global Data**: Often operates on global or non-protected data, leading to potential issues with data consistency.
* **Sequential Execution**: Program execution follows a sequential flow with  conditional statements and loops for control.
* **Reusability and Modularity**: Code can be reused through functions, but maintaining large codebases can be challenging as functions might lack context about the data they manipulate.
* Basic unit of modularity is the *function*.
---
::: title 
Object-Oriented Programming (OOP)
:::
* **Class-Centric**: Organize code into classes, encapsulating data and behaviors related to an object.
* **Encapsulation**: Promotes data hiding, ensuring that internal object states are protected and only accessible through the use of public interfaces.
* **Inheritance and Polymorphism**: Enables code reusability and flexibility by allowing classes to inherit attributes and methods from other classes and method overriding.
* **Modularity and Maintainability**: Enhances modularity, making large codebases easier to maintain and extend, as related data and behaviors are grouped together.
* Basic unit of modularity is the *class* (or *structure*).
---
::: title 
Central Concepts -- Encapsulation
:::
* **Unified Structure**: Through the concept of bundling we combine related data elements (*attributes*) with the functions (*methods*) that manipulate that data into a single entity (*object*).
* **Data Hiding**: Encapsulation also ensures that our internal representation is hidden from the outside. This prevents external code from making changes unexpectedly.
		* Principle of **least privilege**.
*  **Controlled Access**: By using public methods (*accessors* and *mutators*), the class controls how it's data is access or modified, providing a layer of protection and reducing the likelihood of bugs.
* **Ease of Maintenance**: Encapsulation promotes modularity in code design, as each object manages it own state and behavior. This modular approach makes it easier to manage large and complex systems by breaking them down into smaller, more manageable pieces.
---
::: title 
Encapsulation Example
:::

```c++ 
class Square {
	public:
		int getSide() const { return side; }
		void setSide(int newSide) { side = newSide; }

	private:
		int side; 
};
```

*  **Unified Structure**: The data (`side`) is bundled with the functions (`getSide()` and `setSide()`) that operate on it.
* **Data Hiding**: The `private` keyword means that only the functions labeled as `public` are able to access that attribute.
* **Controlled Access**: The only access to our data is maintained by the functions.
* **Ease of Maintenance**: Any time we need to modify the square the code for that will be contained within this class.
---
::: title 
Central Concepts -- Inheritance
:::

* **Factoring out Common Data/Behavior**: Allows you to extract shared attributes and methods into a common class reducing duplication by centralizing common code.
* **Standardizing a Common Interface**: Provides a way to define a common interface which all classes must adhere to ensuring consistent interaction between objects.
* **Facilitate Extensibility**: Ease of adding new classes that build on the functionality of a common class without altering the original code base supporting growth of the application while preserving it's existing structure.
---
::: title 
Inheritance Example
:::

```c++ 
class Shape {
	public:
		std::pair<int,int> getCoordinates() const { return std::pair<int,int>(x,y); }
		void setCoordinates(int newX, int newY) { x = newX;	y = newY; }
	private:
		int x = 0; int y = 0;
};

class Square : public Shape {
	public:
		int getSide() const { return side; }
		void setSide(int newSide) { side = newSide; }
	private:
		int side = 1; 
};
```
---
::: title 
Inheritance Example
:::
```c++ 
class Shape {
	public:
		std::pair<int,int> getCoordinates() const { return std::pair<int,int>(x,y); }
		void setCoordinates(int newX, int newY) { x = newX;	y = newY; }
	private:
		int x = 0; int y = 0;
};
```
*  **Factoring out Common Data/Behavior**: We have removed data/behaviors common to all Shapes (`x` and `y` coordinates).
* **Standardizing a Common Interface**: With the Shape we have declared that all shapes will have an `x` and `y` coordinate and those can be changed through these methods.
* **Facilitate Extensibility**: We can now add any different shape you can think of using the common `Shape` class without *having to* modify existing code.

---
::: title 
Terminology
:::

* **Class** - basically like a *structure*. Encapsulates data and functions that are related.
	* The class is the *blueprint* describing this new thing.
* **Object** - an instance of a class.
	* The object is the real thing build from the blueprint.
* **Attributes** - a class's member *data*.
* **Methods** - a class's member *functions*.

We will use `class` and `struct` somewhat interchangeably.

---
::: title 
Class Syntax
:::

```c++
class ClassName {
	declaration;
	declaration;
};

struct Rectangle {       // Public by default
	double length;
	double width;
	double area;         // Static area value
};

class Rectangle {        // Private by default
	public:
		double length;
		double width;
		double area();   // Method to calculate area
};
```
---
::: title 
Access Specifiers
:::

* `public`: Available both inside and outside the class definition.
* `private`: Only available inside the class definition.
* `protected`: Used in inheritance which we will see later. Currently, treat this as `private`.
Order doesn't matter. Default is `private` for `class`. (`public` for `struct`).

---
::: title 
Access Specifier Examples
:::
```c++
class Square {
	public:
		int getSide() const { return side; }
		void setSide(int newSide) { side = newSide; }
	private:
		int side = 1; 
};
int main() {
	Square mySquare;
	mySquare.side = 2; // !!Compiler error!! - Unable to modify private attribute.
	mySquare.setSide(2); // We are able to modify the side attribute with this public method.
	std::cout << "mySquare side is " << mySquare.side << "\n"; // !!Compiler error!! - Unable to access private attribute.
	std::cout << "mySquare side is " << mySquare.getSide() << "\n"; // We can access the attribute with this method.
}
```

---
::: title
Methods
:::

* Prototype in *class declaration*.
* Definition usually in a seperate *implementation file*.
	* May however also be in the same file.
* *Scope resolution operator* (`::`) is used to establish ownership of an identifier.
	* Must be used when splitting method definitions from the class declaration.
* Private Methods - When are they useful?

---
::: title
Separation of Definition and Implementation
:::
```c++
// Filename: Square.h
class Square {
	public:
		int getSide();
		void setSide(int newSide) const;
	private:
		int side; 
};

// Filename: Square.cpp
int Square::getSide() const { return side; }
void Square::setSide(int newSide) { side = newSide; }

```

---
::: title
Accessors and Mutators
:::
* **Accessors**: Allow access of the attributes of the class object. These should not be able to modify the attributes and thus should be marked as `const`.
* **Mutators**: Allow modification of the attributes of the class object.
* Sometimes also referred to as *getters* and *setters*.
* Provide a way to safely access or modify data members.
* Follow the Principle of *least privilege*.
* Allow the avoidance of stale data.
* Allow the avoidance of incorrect states.
---
::: title
Constructors
:::
* Allow an object to be *instantiated* (created) in an already working state.
	* Contrasts can be drawn with the *uninitialized* state that primitive data types and `struct` begin with.
* Constructors **do not** have any return type.
* Constructors have the same name as the class.
* **Default Constructor** is a constructor that takes no parameters and is used to create a "default" or "blank" object.
* Constructors may take parameters to allow *initialization* during instantiation.
* Classes do not always have a default constructor.